import os
import shutil
from pathlib import Path
from typing import Iterable, List, Optional, Sequence, Set

from setuptools import Command

from buildkit.utils import get_cpy_suffix
from buildkit.summary import filter_files


TEMP_BUILD_DIR = os.environ.get("BUILD_TEMP_DIR", ".build_package_tmp")

# Default suffix patterns that will be removed by the clean command.
# Compiled suffix needs to be detected dynamically for cross-platform support.
_DEFAULT_COMPILED_SUFFIX = get_cpy_suffix()
C_SOURCE_PATTERNS: Sequence[str] = ("*.c",)
COMPILED_SUFFIX_PATTERNS: Sequence[str] = (
    f"*{_DEFAULT_COMPILED_SUFFIX}" if _DEFAULT_COMPILED_SUFFIX else "*.so",
    "*.so",
    "*.pyd",
)
DEFAULT_SUFFIX_PATTERNS: Sequence[str] = (*C_SOURCE_PATTERNS, *COMPILED_SUFFIX_PATTERNS)


def normalize_patterns(patterns: Sequence[str]) -> List[str]:
    seen: Set[str] = set()
    normalized: List[str] = []
    for pattern in patterns:
        if not pattern:
            continue
        value = pattern.strip()
        if not value:
            continue
        if value.startswith('.'):
            value = f"*{value}"
        if value not in seen:
            seen.add(value)
            normalized.append(value)
    return normalized


def iter_matched_files(patterns: Sequence[str], base_path: Path = Path(".")) -> List[Path]:
    """Return a list of files matching the provided glob patterns."""

    base_path = Path(base_path)
    matched: Set[Path] = set()
    for pattern in normalize_patterns(patterns):
        for path in base_path.rglob(pattern):
            if path.is_file():
                matched.add(path)
    return sorted(matched)


def remove_files(files: Iterable[Path]) -> List[Path]:
    """Remove the provided files and return the successfully deleted ones."""

    removed: List[Path] = []
    for file_path in files:
        try:
            resolved = Path(file_path)
            resolved.unlink()
            removed.append(resolved)
            print(f"ðŸ—‘ Removed {file_path}")
        except FileNotFoundError:
            continue
        except Exception as exc:  # pragma: no cover - log unexpected errors
            print(f"âš  Failed to remove {file_path}: {exc}")
    return removed


class ArtifactCleaner:
    """Utility helper that performs artifact cleanup with optional keep patterns."""

    def __init__(self, base_path: Path = Path(".")) -> None:
        self.base_path = Path(base_path)
        self._patterns: List[str] = list(DEFAULT_SUFFIX_PATTERNS)
        self._keep_patterns: List[str] = []

    # -- Configuration -----------------------------------------------------
    def set_patterns(self, patterns: Sequence[str]) -> None:
        self._patterns = normalize_patterns(patterns)

    def set_keep_patterns(self, patterns: Sequence[str]) -> None:
        self._keep_patterns = normalize_patterns(patterns)

    # -- Core operations ---------------------------------------------------
    def collect_files(self) -> List[Path]:
        matched_files = iter_matched_files(self._patterns, self.base_path)
        if not self._keep_patterns:
            return matched_files
        return list(filter_files(matched_files, self._keep_patterns))

    def purge_files(self, files: Optional[Iterable[Path]] = None) -> List[Path]:
        targets = list(files) if files is not None else self.collect_files()
        return remove_files(targets)

    def remove_build_dirs(self) -> None:
        shutil.rmtree("build", ignore_errors=True)
        shutil.rmtree(TEMP_BUILD_DIR, ignore_errors=True)

    def clean(self, remove_build_dirs: bool = True) -> List[Path]:
        removed = self.purge_files()
        if remove_build_dirs:
            self.remove_build_dirs()
        return removed


class CleanCommand(Command):
    """Clean build artifacts such as .c, .so/.pyd files and build directories."""

    description = "Clean build artifacts generated by buildkit and setuptools"
    user_options = [
        (
            "suffixes=",
            None,
            "Comma separated glob patterns for files to remove (default: *.c, *.so, *.pyd)",
        )
    ]

    def initialize_options(self):
        self.suffixes: Optional[Sequence[str]] = None
        self._patterns: List[str] = list(DEFAULT_SUFFIX_PATTERNS)
        self._cleaner = ArtifactCleaner()

    def finalize_options(self):
        if self.suffixes is None:
            env_suffixes = os.environ.get("BUILD_CLEAN_SUFFIXES")
            if env_suffixes:
                self.suffixes = env_suffixes

        if isinstance(self.suffixes, str):
            parsed = [part.strip() for part in self.suffixes.split(",") if part.strip()]
            self._patterns = normalize_patterns(parsed or DEFAULT_SUFFIX_PATTERNS)
        elif self.suffixes is None:
            self._patterns = list(normalize_patterns(DEFAULT_SUFFIX_PATTERNS))
        else:
            self._patterns = normalize_patterns(list(self.suffixes))

    def set_suffixes(self, suffixes: Sequence[str]):
        """Allow programmatic configuration of suffix patterns."""

        self._patterns = normalize_patterns(suffixes)

    def run(self):
        self._cleaner.set_patterns(self._patterns)
        self._cleaner.clean()
